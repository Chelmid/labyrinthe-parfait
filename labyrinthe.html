<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="./style.css">

    <title>result labyrinthe</title>
</head>

<body>
    <div id="labyrinthe"></div>

    <script>

        //recupérer dans url les parametre largeur et hauteur
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const hauteur = urlParams.get('hauteur')
        const largeur = urlParams.get('largeur')

        //taille du labyrinthe
        let mazeWidth = largeur;
        let mazeHeight = hauteur;

        // initial du labyrinthe
        window.addEventListener("load", init);
        function init() {

            createBlankMaze();

            paint();

        }

        function paint() {

            let startAtRow = 1;
            let startAtCol = 1;

            addRoute(startAtRow, startAtCol, false, /*"rgb(255, 255, 255)"*/);

        }

        function addRoute(startAtRow, startAtCol, createDetour, backgroundColorRoute) {


            let validExits = ["right", "bottom", "left", "top"];

            let remainingExits = { "right": 1 + startAtRow + startAtCol * (mazeWidth + 1), "bottom": startAtRow + (startAtCol+1) * mazeWidth, "left":  startAtRow + startAtCol * (mazeWidth+1), "top":  startAtRow + startAtCol * mazeWidth};

            let nextExits = [];

            let lastCells = [];

            let rowIndex = startAtRow;

            let colIndex = startAtCol;

            let currentCell = document.getElementById("cell_" + rowIndex + "_" + colIndex);

            let exit;

            let lastExit;

            let exitIndex;

            let loop = 0;

            let maxLoops = 3 * mazeWidth * mazeHeight;

            let nextPossibleCell;

            while (loop < ((mazeWidth * mazeHeight) - 1)) {


                nextExits = [];

                // possblilité de la cellule suivant
                for (i = 0; i < validExits.length; i++) {

                    switch (validExits[i]) {

                        case "right":
                            nextPossibleCell = document.getElementById("cell_" + rowIndex + "_" + (colIndex + 1));
                            break;

                        case "left":
                            nextPossibleCell = document.getElementById("cell_" + rowIndex + "_" + (colIndex - 1));
                            break;

                        case "bottom":
                            nextPossibleCell = document.getElementById("cell_" + (rowIndex + 1) + "_" + colIndex);
                            break;

                        case "top":
                            nextPossibleCell = document.getElementById("cell_" + (rowIndex - 1) + "_" + colIndex);
                            break;

                    }
                    
                    if (nextPossibleCell != null) {

                        if (nextPossibleCell.getAttribute("occupied") != "true") {

                            for (t = 0; t < remainingExits[validExits[i]]; t++) {

                                nextExits.push(validExits[i]);

                            }

                        }

                    }

                }

                if (nextExits.length == 0) {

                    if (createDetour == true) {

                        return false;


                    } else {

                        lastCells.splice(lastCells.length-1, 1);
                        
                        rowIndex = lastCells[lastCells.length - 1][0];
                        colIndex = lastCells[lastCells.length - 1][1];
                        
                        currentCell = document.getElementById("cell_" + rowIndex + "_" + colIndex);

                        continue;

                    }

                }

                exitIndex = Math.floor(Math.random() * Math.floor(nextExits.length));

                exit = nextExits[exitIndex];
                
                if (createDetour == false) {

                    currentCell.style["border-" + exit] = "none";

                } else {

                    if (!(exit == "right" && colIndex == mazeWidth - 1 && rowIndex == mazeHeight) &&
                        !(exit == "bottom" && colIndex == mazeWidth && rowIndex == mazeHeight - 1)) {

                        currentCell.style["border-" + exit] = "none";

                    }
                }

                switch (exit) {

                    case "right":

                        colIndex = colIndex + 1;
                        /*remainingExits.left++;
                        remainingExits.right--;*/
                        break;

                    case "bottom":

                        rowIndex = rowIndex + 1;
                        /*remainingExits.top++;
                        remainingExits.bottom--;*/
                        break;

                    case "left":

                        colIndex = colIndex - 1;
                        /*remainingExits.left--;
                        remainingExits.right++;*/
                        break;

                    case "top":

                        rowIndex = rowIndex - 1;
                        /*remainingExits.top--;
                        remainingExits.bottom++;*/
                        break;

                }

                lastCells.push([rowIndex, colIndex]);

                currentCell = document.getElementById("cell_" + rowIndex + "_" + colIndex);

                switch (exit) {

                    case "right":

                        currentCell.style["border-left"] = "none";
                        break;

                    case "bottom":

                        currentCell.style["border-top"] = "none";
                        break;

                    case "left":

                        currentCell.style["border-right"] = "none";
                        break;

                    case "top":

                        currentCell.style["border-bottom"] = "none";
                        break;

                }

                if (rowIndex == mazeHeight && colIndex == mazeWidth) {

                    break;

                }

                currentCell.style.backgroundColor = backgroundColorRoute;
                currentCell.setAttribute("occupied", "true");

                lastExit = exit;

                loop++;

            }

        }

        function createBlankMaze() {

            let rowIndex, colIndex;

            let table = document.createElement("table");
            let tbody = document.createElement("tbody");

            for (rowIndex = 0; rowIndex <= mazeHeight - 1; rowIndex++) {

                let row = document.createElement("tr");

                for (colIndex = 0; colIndex <= mazeWidth - 1; colIndex++) {

                    let col = document.createElement("td");

                    if (rowIndex == 0 && colIndex == 0) {

                        col.style.backgroundColor = "rgb(255,0,0)";
                        col.setAttribute("type", "start");

                    } else if (rowIndex == mazeHeight-1 && colIndex == mazeWidth-1) {
                        
                        col.style.backgroundColor = "rgb(0,244,0)";
                        col.setAttribute("type", "finish");

                    }

                    col.setAttribute("id", "cell_" + rowIndex + "_" + colIndex);

                    row.appendChild(col);

                }

                tbody.appendChild(row);

            }

            table.appendChild(tbody);

            document.getElementById("labyrinthe").appendChild(table);

        }
    </script>
</body>

</html>